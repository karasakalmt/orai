import { EventListenerService } from './event-listener.service';
import { OracleContractService } from '../contracts/OracleContract.service';
import { getComputeService, getStorageService } from './service-factory';
import { logger } from '../utils/logger';
import { ethers } from 'ethers';

/**
 * Relayer Service
 * Automatically processes oracle questions and submits answers back to the blockchain
 */
export class RelayerService {
  private eventListener: EventListenerService;
  private oracleContract: OracleContractService;
  private isRunning: boolean = false;
  private processedQuestions: Set<string> = new Set();

  constructor(privateKey: string) {
    if (!privateKey) {
      throw new Error('Private key required for relayer service');
    }

    this.eventListener = new EventListenerService(privateKey);
    this.oracleContract = new OracleContractService(privateKey);
  }

  /**
   * Start the relayer service
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Relayer service already running');
      return;
    }

    logger.info('üöÄ Starting Relayer Service...');

    // Listen for new questions
    this.eventListener.on('question:submitted', async (data) => {
      await this.handleNewQuestion(data);
    });

    // Listen for answers (for logging/monitoring)
    this.eventListener.on('answer:submitted', (data) => {
      logger.info({
        questionId: data.questionId,
        relayer: data.relayer
      }, 'Answer submitted to blockchain');
    });

    // Start listening to blockchain events
    this.eventListener.start();

    this.isRunning = true;
    logger.info('‚úÖ Relayer Service started successfully');
  }

  /**
   * Stop the relayer service
   */
  stop(): void {
    if (!this.isRunning) {
      logger.warn('Relayer service not running');
      return;
    }

    logger.info('Stopping Relayer Service...');

    this.eventListener.stop();
    this.eventListener.removeAllListeners();

    this.isRunning = false;
    logger.info('Relayer Service stopped');
  }

  /**
   * Handle a new question submission
   */
  private async handleNewQuestion(data: {
    questionId: string;
    asker: string;
    question: string;
    fee: bigint;
  }): Promise<void> {
    const { questionId, asker, question, fee } = data;

    // Check if already processed
    if (this.processedQuestions.has(questionId)) {
      logger.debug({ questionId }, 'Question already processed, skipping');
      return;
    }

    logger.info({
      questionId,
      asker,
      question: question.substring(0, 100) + '...',
      fee: ethers.formatEther(fee) + ' ETH'
    }, 'üì• New question received - starting processing');

    try {
      // Mark as processing
      this.processedQuestions.add(questionId);

      // Step 1: Get full question details from contract
      const questionDetails = await this.oracleContract.getQuestion(questionId);

      logger.info({ questionId }, 'Step 1/4: Question details retrieved');

      // Step 2: Process with 0G Compute
      const computeService = await getComputeService();
      const computeJob = await computeService.submitInferenceJob({
        questionText: questionDetails.question,
        referenceUrls: questionDetails.referenceUrls,
        model: 'gpt-4',
        priority: 'high',
      });

      logger.info({
        questionId,
        jobId: computeJob.jobId
      }, 'Step 2/4: Compute job submitted');

      // Wait for compute job to complete
      let jobResult = null;
      let attempts = 0;
      const maxAttempts = 60; // 5 minutes max

      while (!jobResult && attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds

        const status = await computeService.getJobStatus(computeJob.jobId);
        logger.debug({
          questionId,
          jobId: computeJob.jobId,
          status: status.status,
          progress: status.progress
        }, 'Checking compute job status');

        if (status.status === 'completed') {
          jobResult = await computeService.getJobResult(computeJob.jobId);
        } else if (status.status === 'failed') {
          throw new Error('Compute job failed: ' + status.message);
        }

        attempts++;
      }

      if (!jobResult) {
        throw new Error('Compute job timeout after ' + (maxAttempts * 5) + ' seconds');
      }

      logger.info({
        questionId,
        answer: jobResult.output.substring(0, 100) + '...'
      }, 'Step 3/4: Answer generated by AI');

      // Step 3: Store answer in 0G Storage with comprehensive data
      const storageService = await getStorageService();
      const storageResult = await storageService.storeAnswer({
        questionId,
        questionText: question,
        answerText: jobResult.output,
        evidenceSummary: 'AI-generated answer using 0G Compute decentralized inference',
        evidence: [], // TODO: Add evidence sources when available
        model: 'phala/gpt-oss-120b', // TODO: Get from compute result
        modelHash: jobResult.modelHash,
        inputHash: jobResult.inputHash,
        outputHash: jobResult.outputHash,
        timestamp: Date.now()
      });

      logger.info({
        questionId,
        storageHash: storageResult.storageHash,
        storageUrl: storageResult.storageUrl
      }, 'Step 4/4: Answer stored in 0G Storage');

      // Save to local database
      const { prisma } = await import('../config/database');

      // Upsert question
      await prisma.question.upsert({
        where: { questionId },
        create: {
          questionId,
          questionText: question,
          referenceUrls: [],
          submitter: asker,
          status: 'answered',
          feePaid: '0',
          timestamp: new Date()
        },
        update: {
          status: 'answered'
        }
      });

      // Create answer
      await prisma.answer.upsert({
        where: { questionId },
        create: {
          questionId,
          answerText: jobResult.output,
          evidenceSummary: 'AI-generated answer using 0G Compute decentralized inference',
          storageHash: storageResult.storageHash,
          modelHash: jobResult.modelHash,
          inputHash: jobResult.inputHash,
          outputHash: jobResult.outputHash,
          verified: false,
          timestamp: new Date()
        },
        update: {
          answerText: jobResult.output,
          storageHash: storageResult.storageHash,
          modelHash: jobResult.modelHash,
          inputHash: jobResult.inputHash,
          outputHash: jobResult.outputHash
        }
      });

      logger.info({ questionId }, 'Saved question and answer to database');

      // Step 5: Submit answer back to Oracle contract
      const submitResult = await this.oracleContract.submitAnswer(
        questionId,
        jobResult.output,
        storageResult.storageHash,
        jobResult.modelHash,
        jobResult.inputHash,
        jobResult.outputHash
      );

      logger.info({
        questionId,
        txHash: submitResult.txHash,
        storageHash: storageResult.storageHash
      }, '‚úÖ Answer submitted to blockchain successfully');

      // Log complete flow
      logger.info({
        questionId,
        asker,
        question: question.substring(0, 50) + '...',
        answer: jobResult.output.substring(0, 50) + '...',
        computeJobId: computeJob.jobId,
        storageHash: storageResult.storageHash,
        txHash: submitResult.txHash,
        processingTime: jobResult.processingTime,
        tokensUsed: jobResult.tokensUsed
      }, 'üéâ Question-Answer cycle completed successfully');

    } catch (error) {
      logger.error({
        error,
        questionId,
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      }, '‚ùå Failed to process question');

      // Remove from processed set so it can be retried
      this.processedQuestions.delete(questionId);
    }
  }

  /**
   * Get relayer status
   */
  getStatus(): {
    isRunning: boolean;
    processedCount: number;
    processedQuestions: string[];
  } {
    return {
      isRunning: this.isRunning,
      processedCount: this.processedQuestions.size,
      processedQuestions: Array.from(this.processedQuestions),
    };
  }

  /**
   * Clear processed questions history
   */
  clearHistory(): void {
    this.processedQuestions.clear();
    logger.info('Processed questions history cleared');
  }
}
